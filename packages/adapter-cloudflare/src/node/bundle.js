import fs from 'node:fs/promises';
import path from 'node:path';
import { pathToFileURL } from 'node:url';
import esbuild from 'esbuild';

// -------------------------
// Simple route discovery (JS only; mirrors your CLI behavior)
// -------------------------
const IGNORED = /^_|\/_/; // ignore underscore files/folders
function fileToRoute(root, fileAbs) {
  const rel = path.posix
    .join(...path.relative(root, fileAbs).split(path.sep))
    .replace(/\.(mjs|cjs|js)$/i, '');

  if (rel === 'index') return '/';
  const segs = rel
    .split('/')
    .map((s) => {
      if (s === 'index') return null;
      if (/^\[\.{3}.+\]$/.test(s)) return '*' + s.slice(4, -1); // [...slug] -> *slug
      if (/^\[.+\]$/.test(s)) return ':' + s.slice(1, -1); // [id] -> :id
      return s;
    })
    .filter(Boolean);

  return '/' + segs.join('/');
}

async function walkJs(dir) {
  const out = [];
  const ents = await fs.readdir(dir, { withFileTypes: true }).catch(() => []);
  for (const e of ents) {
    if (e.name.startsWith('_')) continue;
    const p = path.join(dir, e.name);
    if (e.isDirectory()) out.push(...(await walkJs(p)));
    else if (e.isFile() && /\.(mjs|cjs|js)$/i.test(e.name)) out.push(p);
  }
  return out;
}

// Load a module and normalize {default or data(), paths()?}
async function loadRouteModule(fileAbs) {
  // Use dynamic import so ESM/CJS both work (CJS via Node’s cjs interop)
  const mod = await import(pathToFileURL(fileAbs).href);
  // normalize: prefer named data(), else default if it's a function or plain value
  let hasData = false;
  let hasPaths = false;

  const out = {};

  if (typeof mod.paths === 'function') {
    out.paths = mod.paths.toString();
    hasPaths = true;
  }
  if (typeof mod.data === 'function') {
    out.data = mod.data.toString();
    hasData = true;
  } else if (typeof mod.default === 'function') {
    out.data = mod.default.toString();
    hasData = true;
  } else if (typeof mod.default !== 'undefined') {
    // inline value producer
    const v = JSON.stringify(mod.default);
    out.data = `async function data(){ return ${v}; }`;
    hasData = true;
  }

  if (!hasData) {
    // If neither data() nor default present, emit a null data (so runtime can error nicely)
    out.data = `async function data(){ return { _error: "No data() or default export" } }`;
  }

  return { code: out, hasPaths };
}

function routeTypeFromPattern(route) {
  if (route.includes('*')) return 'catchall';
  if (route.includes(':')) return 'dynamic';
  return 'static';
}

function stableSortRoutes(routes) {
  // 1) static 2) dynamic 3) catchall
  const rank = { static: 0, dynamic: 1, catchall: 2 };
  return routes.sort((a, b) => {
    const ra = rank[a.type] ?? 3;
    const rb = rank[b.type] ?? 3;
    if (ra !== rb) return ra - rb;
    return a.route.localeCompare(b.route);
  });
}

export async function bundle({
  cwd = process.cwd(),
  srcDir = 'src-api',
  outFile = 'dist/worker.mjs',
  prettyDefault = false,
  watch = false,
}) {
  const root = path.resolve(cwd, srcDir);
  const files = await walkJs(root);

  const entries = [];
  for (const fileAbs of files) {
    if (IGNORED.test(fileAbs.replace(root, ''))) continue;
    const route = fileToRoute(root, fileAbs);
    const type = routeTypeFromPattern(route);
    const { code } = await loadRouteModule(fileAbs);

    entries.push({
      file: path.relative(cwd, fileAbs).replace(/\\/g, '/'),
      route,
      type,
      dataSrc: code.data,
      pathsSrc: code.paths || null,
    });
  }

  const list = stableSortRoutes(entries);

  const registrySource = `
export const REGISTRY = [
${list
  .map(
    (e) => `  {
    route: ${JSON.stringify(e.route)},
    type: ${JSON.stringify(e.type)},
    file: ${JSON.stringify(e.file)},
    mod: (function(){
      ${e.pathsSrc ? `const paths = ${e.pathsSrc};` : ''}
      const data = ${e.dataSrc};
      return { ${e.pathsSrc ? 'paths,' : ''} data };
    })()
  }`
  )
  .join(',\n')}
];
export const DEFAULT_PRETTY = ${prettyDefault ? 'true' : 'false'};
`;

  // Write a temporary module for registry + runtime glue and let esbuild concat/minify
  const tmpDir = path.join(cwd, '.statikapi-cf-tmp');
  await fs.mkdir(tmpDir, { recursive: true });
  const entryFile = path.join(tmpDir, 'entry.mjs');
  const runtimeFile = path.join(tmpDir, 'runtime.mjs');

  // write entry + runtime
  await fs.writeFile(entryFile, registrySource, 'utf8');
  await fs.writeFile(runtimeFile, WORKER_RUNTIME_JS, 'utf8');

  const buildOpts = {
    entryPoints: [runtimeFile],
    bundle: true,
    format: 'esm',
    platform: 'browser',
    outfile: path.resolve(cwd, outFile),
    define: { 'process.env.NODE_ENV': '"production"' },
    banner: { js: '// generated by @statikapi/adapter-cf\n' },
    logLevel: 'silent',
  };

  if (watch) {
    const ctx = await esbuild.context(buildOpts);
    await ctx.watch();
    // don’t rm tmpDir in watch mode
    return;
  }

  await esbuild.build(buildOpts);

  try {
    await fs.rm(tmpDir, { recursive: true, force: true });
  } catch {}
}

// -------------------------
// Worker runtime (pure JS) inlined here
// -------------------------
const WORKER_RUNTIME_JS = `
  import { REGISTRY, DEFAULT_PRETTY } from './entry.mjs';

  function isPlainObject(x){ return Object.prototype.toString.call(x) === '[object Object]'; }
  function assertSerializable(v, seen = new Set()) {
    const t = typeof v;
    if (v == null) return;
    if (t === 'string' || t === 'boolean') return;
    if (t === 'number') { if (!Number.isFinite(v)) throw new Error('Not JSON-serializable: Number must be finite'); return; }
    if (Array.isArray(v)) { for (const it of v) assertSerializable(it, seen); return; }
    if (t === 'object') {
      if (seen.has(v)) throw new Error('Not JSON-serializable: Circular structure detected');
      if (!isPlainObject(v)) throw new Error('Not JSON-serializable: Only plain objects/arrays allowed');
      seen.add(v);
      for (const k of Object.keys(v)) assertSerializable(v[k], seen);
      seen.delete(v);
      return;
    }
    throw new Error('Not JSON-serializable: ' + t + ' is not allowed');
  }

  function splitRoute(route) {
    if (route === '/') return [];
    return route.replace(/^\\//,'').split('/');
  }

  function concreteFromPattern(patternSegs, entry) {
    // entry can be string (for single dynamic) or array for catchall
    const params = {};
    const segs = [];
    let idxDyn = 0;
    for (const s of patternSegs) {
      if (s.startsWith(':')) {
        const val = Array.isArray(entry) ? entry[idxDyn++] : entry;
        params[s.slice(1)] = String(val);
        segs.push(String(val));
      } else if (s.startsWith('*')) {
        const name = s.slice(1);
        const arr = Array.isArray(entry) ? entry.slice(idxDyn) : (Array.isArray(entry) ? entry : [entry]);
        params[name] = arr.map(String);
        segs.push(...params[name]);
        break;
      } else {
        segs.push(s);
      }
    }
    const route = '/' + segs.join('/');
    return { route, params };
  }

  async function expandAllRoutes(registry) {
    const out = [];
    for (const r of registry) {
      const patternSegs = splitRoute(r.route);
      if (r.type === 'static') {
        out.push({ ...r, concreteRoute: r.route, params: {} });
        continue;
      }
      if (r.mod && typeof r.mod.paths === 'function') {
        const entries = await r.mod.paths();
        if (!Array.isArray(entries)) throw new Error('paths() must return an array');
        for (const entry of entries) {
          if (r.type === 'dynamic' && (typeof entry !== 'string' || !entry || entry.includes('/'))) {
            throw new Error('paths() for ' + r.route + ' must be string[] without "/"');
          }
          if (r.type === 'catchall') {
            if (!Array.isArray(entry) || !entry.length) throw new Error('paths() for ' + r.route + ' must be non-empty string[] arrays');
            if (entry.some(s => typeof s !== 'string' || !s)) throw new Error('catch-all entries must be non-empty strings');
          }
          const { route, params } = concreteFromPattern(patternSegs, entry);
          out.push({ ...r, concreteRoute: route, params });
        }
      } else {
        // no paths(): skip dynamic/catchall
        // (We still include a "skip" marker if needed by summary)
      }
    }
    return out;
  }

  async function digestETag(text) {
    const enc = new TextEncoder().encode(text);
    const hash = await crypto.subtle.digest('SHA-256', enc);
    const hex = [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, '0')).join('');
    return '"' + hex + '"';
  }

  function r2Key(projectId, concreteRoute) {
    const suffix = concreteRoute === '/' ? '' : concreteRoute.replace(/^\\//, '') + '/';
    return \`\${projectId}/\${suffix}index.json\`;
  }

  async function writeJsonToR2(env, key, text, extraMeta = {}) {
    const httpMetadata = {
      contentType: 'application/json; charset=utf-8',
      cacheControl: 'public, max-age=0, s-maxage=31536000'
    };
    await env.STATIK_BUCKET.put(key, text, { httpMetadata, customMetadata: extraMeta });
  }

  async function readManifest(env, projectId) {
    const k = \`\${projectId}::manifest\`;
    const m = await env.STATIK_MANIFEST.get(k);
    if (!m) return [];
    try { return JSON.parse(m); } catch { return []; }
  }
  async function writeManifest(env, projectId, list) {
    const k = \`\${projectId}::manifest\`;
    await env.STATIK_MANIFEST.put(k, JSON.stringify(list));
  }

  async function handleBuild(req, env) {
    const auth = req.headers.get('authorization') || '';
    const want = 'Bearer ' + (env.STATIK_BUILD_TOKEN || '');
    if (!env.STATIK_BUILD_TOKEN || auth !== want) {
      return new Response('unauthorized', { status: 401 });
    }
    const body = await req.json().catch(() => ({}));
    const projectId = body.projectId || 'default';
    const pretty = body.pretty ?? DEFAULT_PRETTY;

    const t0 = Date.now();
    let written = 0, files = 0, skipped = 0;

    const expanded = await expandAllRoutes(REGISTRY);
    const man = [];

    for (const r of expanded) {
      if (!r.concreteRoute) { skipped++; continue; }
      const ctx = { params: r.params || {}, env };
      const value = await r.mod.data(ctx);
      assertSerializable(value);
      const text = pretty ? JSON.stringify(value, null, 2) : JSON.stringify(value);
      const key = r2Key(projectId, r.concreteRoute);
      const etag = await digestETag(text);
      await writeJsonToR2(env, key, text, { route: r.concreteRoute, etag });

      files++;
      written += (new TextEncoder().encode(text)).length;
      man.push({
        route: r.concreteRoute,
        filePath: key,
        bytes: text.length,
        mtime: Date.now(),
        hash: etag.replace(/"/g, '')
      });
    }

    await writeManifest(env, projectId, man);

    const ms = Date.now() - t0;
    return new Response(JSON.stringify({ ok: true, files, bytes: written, skipped, ms }), {
      headers: { 'content-type': 'application/json' }
    });
  }

  export default {
    async fetch(req, env) {
      const url = new URL(req.url);

      if (req.method === 'POST' && url.pathname === '/__statikapi/build') {
        return handleBuild(req, env);
      }
      if (req.method === 'GET' && url.pathname === '/__statikapi/manifest') {
        const projectId = url.searchParams.get('projectId') || 'default';
        const list = await readManifest(env, projectId);
        return new Response(JSON.stringify(list), { headers: { 'content-type': 'application/json' } });
      }

      // optional: you could later add a read endpoint that serves from R2
      // if (req.method === 'GET') { ... fetch from env.STATIK_BUCKET.get(...) }

      return new Response('Not found', { status: 404 });
    }
  };
`;
