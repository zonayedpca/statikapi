import fs from 'node:fs/promises';
import path from 'node:path';
import { pathToFileURL } from 'node:url';
import esbuild from 'esbuild';

// -------------------------
// Simple route discovery (JS only; mirrors your CLI behavior)
// -------------------------
const IGNORED = /^_|\/_/; // ignore underscore files/folders
function fileToRoute(root, fileAbs) {
  const rel = path.posix
    .join(...path.relative(root, fileAbs).split(path.sep))
    .replace(/\.(mjs|cjs|js)$/i, '');

  if (rel === 'index') return '/';
  const segs = rel
    .split('/')
    .map((s) => {
      if (s === 'index') return null;
      if (/^\[\.{3}.+\]$/.test(s)) return '*' + s.slice(4, -1); // [...slug] -> *slug
      if (/^\[.+\]$/.test(s)) return ':' + s.slice(1, -1); // [id] -> :id
      return s;
    })
    .filter(Boolean);

  return '/' + segs.join('/');
}

async function walkJs(dir) {
  const out = [];
  const ents = await fs.readdir(dir, { withFileTypes: true }).catch(() => []);
  for (const e of ents) {
    if (e.name.startsWith('_')) continue;
    const p = path.join(dir, e.name);
    if (e.isDirectory()) out.push(...(await walkJs(p)));
    else if (e.isFile() && /\.(mjs|cjs|js)$/i.test(e.name)) out.push(p);
  }
  return out;
}

// Load a module and normalize {default or data(), paths()?}
async function loadRouteModule(fileAbs) {
  // Use dynamic import so ESM/CJS both work (CJS via Node’s cjs interop)
  const mod = await import(pathToFileURL(fileAbs).href);
  // normalize: prefer named data(), else default if it's a function or plain value
  let hasData = false;
  let hasPaths = false;

  const out = {};

  if (typeof mod.paths === 'function') {
    out.paths = mod.paths.toString();
    hasPaths = true;
  }
  if (typeof mod.data === 'function') {
    out.data = mod.data.toString();
    hasData = true;
  } else if (typeof mod.default === 'function') {
    out.data = mod.default.toString();
    hasData = true;
  } else if (typeof mod.default !== 'undefined') {
    // inline value producer
    const v = JSON.stringify(mod.default);
    out.data = `async function data(){ return ${v}; }`;
    hasData = true;
  }

  if (!hasData) {
    // If neither data() nor default present, emit a null data (so runtime can error nicely)
    out.data = `async function data(){ return { _error: "No data() or default export" } }`;
  }

  return { code: out, hasPaths };
}

function routeTypeFromPattern(route) {
  if (route.includes('*')) return 'catchall';
  if (route.includes(':')) return 'dynamic';
  return 'static';
}

function stableSortRoutes(routes) {
  // 1) static 2) dynamic 3) catchall
  const rank = { static: 0, dynamic: 1, catchall: 2 };
  return routes.sort((a, b) => {
    const ra = rank[a.type] ?? 3;
    const rb = rank[b.type] ?? 3;
    if (ra !== rb) return ra - rb;
    return a.route.localeCompare(b.route);
  });
}

export async function bundle({
  cwd = process.cwd(),
  srcDir = 'src-api',
  outFile = 'dist/worker.mjs',
  prettyDefault = false,
  watch = false,
}) {
  const root = path.resolve(cwd, srcDir);
  const files = await walkJs(root);

  const entries = [];
  for (const fileAbs of files) {
    if (IGNORED.test(fileAbs.replace(root, ''))) continue;
    const route = fileToRoute(root, fileAbs);
    const type = routeTypeFromPattern(route);
    const { code } = await loadRouteModule(fileAbs);

    entries.push({
      file: path.relative(cwd, fileAbs).replace(/\\/g, '/'),
      route,
      type,
      dataSrc: code.data,
      pathsSrc: code.paths || null,
    });
  }

  const list = stableSortRoutes(entries);

  const registrySource = `
export const REGISTRY = [
${list
  .map(
    (e) => `  {
    route: ${JSON.stringify(e.route)},
    type: ${JSON.stringify(e.type)},
    file: ${JSON.stringify(e.file)},
    mod: (function(){
      ${e.pathsSrc ? `const paths = ${e.pathsSrc};` : ''}
      const data = ${e.dataSrc};
      return { ${e.pathsSrc ? 'paths,' : ''} data };
    })()
  }`
  )
  .join(',\n')}
];
export const DEFAULT_PRETTY = ${prettyDefault ? 'true' : 'false'};
`;

  // Write a temporary module for registry + runtime glue and let esbuild concat/minify
  const tmpDir = path.join(cwd, '.statikapi-cf-tmp');
  await fs.mkdir(tmpDir, { recursive: true });
  const entryFile = path.join(tmpDir, 'entry.mjs');
  const runtimeFile = path.join(tmpDir, 'runtime.mjs');

  // write entry + runtime
  await fs.writeFile(entryFile, registrySource, 'utf8');
  await fs.writeFile(runtimeFile, WORKER_RUNTIME_JS, 'utf8');

  const buildOpts = {
    entryPoints: [runtimeFile],
    bundle: true,
    format: 'esm',
    platform: 'browser',
    outfile: path.resolve(cwd, outFile),
    define: { 'process.env.NODE_ENV': '"production"' },
    banner: { js: '// generated by @statikapi/adapter-cf\n' },
    logLevel: 'silent',
  };

  if (watch) {
    const ctx = await esbuild.context(buildOpts);
    await ctx.watch();
    // don’t rm tmpDir in watch mode
    return;
  }

  await esbuild.build(buildOpts);

  try {
    await fs.rm(tmpDir, { recursive: true, force: true });
  } catch {}
}

// -------------------------
// Worker runtime (pure JS) inlined here
// -------------------------
const WORKER_RUNTIME_JS = `
  import { REGISTRY, DEFAULT_PRETTY } from './entry.mjs';

  function isPlainObject(x){ return Object.prototype.toString.call(x) === '[object Object]'; }
  function assertSerializable(v, seen = new Set()) {
    const t = typeof v;
    if (v == null) return;
    if (t === 'string' || t === 'boolean') return;
    if (t === 'number') { if (!Number.isFinite(v)) throw new Error('Not JSON-serializable: Number must be finite'); return; }
    if (Array.isArray(v)) { for (const it of v) assertSerializable(it, seen); return; }
    if (t === 'object') {
      if (seen.has(v)) throw new Error('Not JSON-serializable: Circular structure detected');
      if (!isPlainObject(v)) throw new Error('Not JSON-serializable: Only plain objects/arrays allowed');
      seen.add(v);
      for (const k of Object.keys(v)) assertSerializable(v[k], seen);
      seen.delete(v);
      return;
    }
    throw new Error('Not JSON-serializable: ' + t + ' is not allowed');
  }

  function splitRoute(route) {
    if (route === '/') return [];
    return route.replace(/^\\//,'').split('/');
  }

  function parseAllowedOrigins(env) {
    const raw = env.STATIK_ALLOWED_ORIGINS || '';
    return raw
      .split(',')
      .map((s) => s.trim())
      .filter(Boolean);
  }

  function isOriginAllowed(origin, env) {
    if (!origin) return true; // server-to-server, curl, etc.
    const allowed = parseAllowedOrigins(env);
    if (!allowed.length) return true; // no restriction configured
    return allowed.includes(origin);
  }

  function isReadAuthorized(req, env) {
    const requireAuth = (env.STATIK_API_REQUIRE_AUTH || 'false').toLowerCase() === 'true';
    if (!requireAuth) return true;

    const auth = req.headers.get('authorization') || '';
    const token = env.STATIK_API_AUTH_TOKEN || '';
    if (!token) return false;

    const want = 'Bearer ' + token;
    return auth === want;
  }

  function corsHeaders(origin, extra = {}) {
    const headers = {
      'content-type': 'application/json; charset=utf-8',
      ...extra,
    };
    if (origin) {
      headers['access-control-allow-origin'] = origin;
      headers['vary'] = 'origin';
    }
    return headers;
  }

  function matchPattern(patternRoute, concreteRoute) {
    const pSegs = splitRoute(patternRoute);
    const cSegs = splitRoute(concreteRoute);

    const params = {};
    let i = 0, j = 0;

    while (i < pSegs.length && j < cSegs.length) {
      const p = pSegs[i];
      const c = cSegs[j];

      if (p.startsWith(':')) {
        params[p.slice(1)] = decodeURIComponent(c);
        i++; j++;
      } else if (p.startsWith('*')) {
        const name = p.slice(1);
        const rest = cSegs.slice(j).map((s) => decodeURIComponent(s));
        params[name] = rest;
        i = pSegs.length;
        j = cSegs.length;
        break;
      } else {
        if (p !== c) return null;   // no match
        i++; j++;
      }
    }

    if (i !== pSegs.length || j !== cSegs.length) return null;
    return params; // matched!
  }

  function findRouteEntry(registry, concreteRoute) {
    for (const r of registry) {
      const params = matchPattern(r.route, concreteRoute);
      if (params) {
        return { routeEntry: r, params };
      }
    }
    return null;
  }

  function concreteFromPattern(patternSegs, entry) {
    // entry can be string (for single dynamic) or array for catchall
    const params = {};
    const segs = [];
    let idxDyn = 0;
    for (const s of patternSegs) {
      if (s.startsWith(':')) {
        const val = Array.isArray(entry) ? entry[idxDyn++] : entry;
        params[s.slice(1)] = String(val);
        segs.push(String(val));
      } else if (s.startsWith('*')) {
        const name = s.slice(1);
        const arr = Array.isArray(entry) ? entry.slice(idxDyn) : (Array.isArray(entry) ? entry : [entry]);
        params[name] = arr.map(String);
        segs.push(...params[name]);
        break;
      } else {
        segs.push(s);
      }
    }
    const route = '/' + segs.join('/');
    return { route, params };
  }

  async function expandAllRoutes(registry) {
    const out = [];
    for (const r of registry) {
      const patternSegs = splitRoute(r.route);
      if (r.type === 'static') {
        out.push({ ...r, concreteRoute: r.route, params: {} });
        continue;
      }
      if (r.mod && typeof r.mod.paths === 'function') {
        const entries = await r.mod.paths();
        if (!Array.isArray(entries)) throw new Error('paths() must return an array');
        for (const entry of entries) {
          if (r.type === 'dynamic' && (typeof entry !== 'string' || !entry || entry.includes('/'))) {
            throw new Error('paths() for ' + r.route + ' must be string[] without "/"');
          }
          if (r.type === 'catchall') {
            if (!Array.isArray(entry) || !entry.length) throw new Error('paths() for ' + r.route + ' must be non-empty string[] arrays');
            if (entry.some(s => typeof s !== 'string' || !s)) throw new Error('catch-all entries must be non-empty strings');
          }
          const { route, params } = concreteFromPattern(patternSegs, entry);
          out.push({ ...r, concreteRoute: route, params });
        }
      } else {
        // no paths(): skip dynamic/catchall
        // (We still include a "skip" marker if needed by summary)
      }
    }
    return out;
  }

  async function digestETag(text) {
    const enc = new TextEncoder().encode(text);
    const hash = await crypto.subtle.digest('SHA-256', enc);
    const hex = [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, '0')).join('');
    return '"' + hex + '"';
  }

  function r2Key(projectId, concreteRoute) {
    // concreteRoute: '/demo' => key 'projectId/demo/index.json'
    // concreteRoute: '/'     => key 'projectId/index.json'
    const suffix = concreteRoute === '/' ? '/index.json' : concreteRoute + '/index.json';
    return \`\${projectId}\${suffix}\`;
  }

  async function writeJsonToR2(env, key, text, extraMeta = {}) {
    const httpMetadata = {
      contentType: 'application/json; charset=utf-8',
      cacheControl: 'public, max-age=0, s-maxage=31536000'
    };
    await env.STATIK_BUCKET.put(key, text, { httpMetadata, customMetadata: extraMeta });
  }

  async function readManifest(env, projectId) {
    const k = \`\${projectId}::manifest\`;
    const m = await env.STATIK_MANIFEST.get(k);
    if (!m) return [];
    try { return JSON.parse(m); } catch { return []; }
  }

  async function writeManifest(env, projectId, list) {
    const k = \`\${projectId}::manifest\`;
    await env.STATIK_MANIFEST.put(k, JSON.stringify(list));
  }

  function r2KeyFromPath(projectId, pathname) {
    // pathname like '/demo/index.json' -> 'projectId/demo/index.json'
    // or '/' -> 'projectId/index.json' if you ever map root
    const clean = pathname === '/' ? '/index.json' : pathname;
    return \`\${projectId}\${clean}\`;
  }

  async function handleRead(req, env) {
    const url = new URL(req.url);
    const origin = req.headers.get('origin') || '';
    const projectId = url.searchParams.get('projectId') || 'default';

    if (!isOriginAllowed(origin, env)) {
      return new Response('forbidden', { status: 403 });
    }

    if (!isReadAuthorized(req, env)) {
      return new Response(
        JSON.stringify({ ok: false, error: 'unauthorized' }),
        { status: 401, headers: corsHeaders(origin) },
      );
    }

    const key = r2KeyFromPath(projectId, url.pathname);
    const obj = await env.STATIK_BUCKET.get(key);

    if (!obj) {
      return new Response(
        JSON.stringify({ ok: false, error: 'not_found' }),
        { status: 404, headers: corsHeaders(origin) },
      );
    }

    const body = await obj.text();

    return new Response(body, {
      headers: corsHeaders(origin, {
        // cache at edge, but easy to invalidate
        'cache-control': 'public, max-age=0, s-maxage=600',
      }),
    });
  }

  async function purgeCacheForPath(env, origin, path) {
    // Minimal: purge Worker cache for this path on this colo.
    // (Global purge via CF API can be added later using env.STATIK_CF_API_TOKEN / STATIK_CF_ZONE_ID.)
    try {
      const url = origin + path;
      await caches.default.delete(new Request(url, { method: 'GET' }));
    } catch (err) {
      // swallow errors; cache purge is best-effort
      console.warn('purgeCacheForPath error', err);
    }
  }

  async function handleOptions(req, env) {
    const origin = req.headers.get('origin') || '';
    if (!isOriginAllowed(origin, env)) {
      return new Response('forbidden', { status: 403 });
    }

    return new Response(null, {
      headers: {
        ...(origin ? { 'access-control-allow-origin': origin } : {}),
        'access-control-allow-methods': 'GET, OPTIONS, POST',
        'access-control-allow-headers': 'Content-Type, Authorization',
        'access-control-max-age': '86400',
        'vary': 'origin',
      },
    });
  }

  async function handleBuildRoute(req, env) {
    const auth = req.headers.get('authorization') || '';
    const want = 'Bearer ' + (env.STATIK_BUILD_TOKEN || '');
    if (!env.STATIK_BUILD_TOKEN || auth !== want) {
      return new Response('unauthorized', { status: 401 });
    }

    const body = await req.json().catch(() => ({}));
    const projectId = body.projectId || 'default';
    const pretty = body.pretty ?? DEFAULT_PRETTY;
    const route = body.route;

    if (!route || typeof route !== 'string') {
      return new Response(JSON.stringify({ ok: false, error: 'Missing "route" in body' }), {
        status: 400,
        headers: { 'content-type': 'application/json' },
      });
    }

    const found = findRouteEntry(REGISTRY, route);
    if (!found) {
      return new Response(JSON.stringify({ ok: false, error: 'No matching route in registry' }), {
        status: 404,
        headers: { 'content-type': 'application/json' },
      });
    }

    const { routeEntry, params } = found;

    const ctx = { params: params || {}, env };
    const value = await routeEntry.mod.data(ctx);
    assertSerializable(value);

    const text = pretty ? JSON.stringify(value, null, 2) : JSON.stringify(value);
    const key = r2Key(projectId, route);
    const etag = await digestETag(text);

    await writeJsonToR2(env, key, text, { route, etag });

    // update manifest: remove old entry for this route, then add fresh one
    const existing = await readManifest(env, projectId);
    const next = (existing || []).filter((e) => e.route !== route);
    const bytes = (new TextEncoder().encode(text)).length;

    next.push({
      route,
      filePath: key,
      bytes,
      mtime: Date.now(),
      hash: etag.replace(/"/g, ''),
    });

    await writeManifest(env, projectId, next);

    // per-route cache purge (worker cache) for the JSON path
    const url = new URL(req.url);
    const origin = url.origin;
    const jsonPath = route === '/' ? '/index.json' : route + '/index.json';
    await purgeCacheForPath(env, origin, jsonPath);

    const resBody = {
      ok: true,
      route,
      filePath: key,
      bytes,
    };

    return new Response(JSON.stringify(resBody), {
      headers: { 'content-type': 'application/json' },
    });
  }

  async function handleBuild(req, env) {
    const auth = req.headers.get('authorization') || '';
    const want = 'Bearer ' + (env.STATIK_BUILD_TOKEN || '');
    if (!env.STATIK_BUILD_TOKEN || auth !== want) {
      return new Response('unauthorized', { status: 401 });
    }
    const body = await req.json().catch(() => ({}));
    const projectId = body.projectId || 'default';
    const pretty = body.pretty ?? DEFAULT_PRETTY;

    const t0 = Date.now();
    let written = 0, files = 0, skipped = 0;

    const expanded = await expandAllRoutes(REGISTRY);
    const man = [];

    for (const r of expanded) {
      if (!r.concreteRoute) { skipped++; continue; }
      const ctx = { params: r.params || {}, env };
      const value = await r.mod.data(ctx);
      assertSerializable(value);
      const text = pretty ? JSON.stringify(value, null, 2) : JSON.stringify(value);
      const key = r2Key(projectId, r.concreteRoute);
      const etag = await digestETag(text);
      await writeJsonToR2(env, key, text, { route: r.concreteRoute, etag });

      // per-route purge for the concrete JSON path
      const url = new URL(req.url);
      const origin = url.origin;
      const jsonPath = r.concreteRoute === '/' ? '/index.json' : r.concreteRoute + '/index.json';
      await purgeCacheForPath(env, origin, jsonPath);

      files++;
      written += (new TextEncoder().encode(text)).length;
      man.push({
        route: r.concreteRoute,
        filePath: key,
        bytes: text.length,
        mtime: Date.now(),
        hash: etag.replace(/"/g, '')
      });
    }

    await writeManifest(env, projectId, man);

    const ms = Date.now() - t0;
    return new Response(JSON.stringify({ ok: true, files, bytes: written, skipped, ms }), {
      headers: { 'content-type': 'application/json' }
    });
  }

  export default {
    async fetch(req, env) {
      const url = new URL(req.url);

      // CORS preflight
      if (req.method === 'OPTIONS') {
        return handleOptions(req, env);
      }

      if (req.method === 'POST' && url.pathname === '/__statikapi/build/route') {
        return handleBuildRoute(req, env);
      }

      if (req.method === 'POST' && url.pathname === '/__statikapi/build') {
        return handleBuild(req, env);
      }
      if (req.method === 'GET' && url.pathname === '/__statikapi/manifest') {
        const projectId = url.searchParams.get('projectId') || 'default';
        const list = await readManifest(env, projectId);
        return new Response(JSON.stringify(list), { headers: { 'content-type': 'application/json' } });
      }

      // Public API: serve JSON directly from R2
      if (req.method === 'GET') {
        // e.g. /demo/index.json -> projectId/demo/index.json
        return handleRead(req, env);
      }

      return new Response('Not found', { status: 404 });
    }
  };
`;
