import fs from 'node:fs/promises';
import path from 'node:path';
import { pathToFileURL } from 'node:url';
import esbuild from 'esbuild';

// -------------------------
// Simple route discovery (JS only; mirrors your CLI behavior)
// -------------------------
const IGNORED = /^_|\/_/; // ignore underscore files/folders
function fileToRoute(root, fileAbs) {
  const rel = path.posix
    .join(...path.relative(root, fileAbs).split(path.sep))
    .replace(/\.(mjs|cjs|js)$/i, '');

  if (rel === 'index') return '/';
  const segs = rel
    .split('/')
    .map((s) => {
      if (s === 'index') return null;
      if (/^\[\.{3}.+\]$/.test(s)) return '*' + s.slice(4, -1); // [...slug] -> *slug
      if (/^\[.+\]$/.test(s)) return ':' + s.slice(1, -1); // [id] -> :id
      return s;
    })
    .filter(Boolean);

  return '/' + segs.join('/');
}

async function walkJs(dir) {
  const out = [];
  const ents = await fs.readdir(dir, { withFileTypes: true }).catch(() => []);
  for (const e of ents) {
    if (e.name.startsWith('_')) continue;
    const p = path.join(dir, e.name);
    if (e.isDirectory()) out.push(...(await walkJs(p)));
    else if (e.isFile() && /\.(mjs|cjs|js)$/i.test(e.name)) out.push(p);
  }
  return out;
}

// Load a module and normalize {default or data(), paths()?}
async function loadRouteModule(fileAbs) {
  // Use dynamic import so ESM/CJS both work (CJS via Node’s cjs interop)
  const mod = await import(pathToFileURL(fileAbs).href);
  // normalize: prefer named data(), else default if it's a function or plain value
  let hasData = false;
  let hasPaths = false;

  const out = {};

  if (typeof mod.paths === 'function') {
    out.paths = mod.paths.toString();
    hasPaths = true;
  }
  if (typeof mod.data === 'function') {
    out.data = mod.data.toString();
    hasData = true;
  } else if (typeof mod.default === 'function') {
    out.data = mod.default.toString();
    hasData = true;
  } else if (typeof mod.default !== 'undefined') {
    // inline value producer
    const v = JSON.stringify(mod.default);
    out.data = `async function data(){ return ${v}; }`;
    hasData = true;
  }

  if (!hasData) {
    // If neither data() nor default present, emit a null data (so runtime can error nicely)
    out.data = `async function data(){ return { _error: "No data() or default export" } }`;
  }

  return { code: out, hasPaths };
}

function routeTypeFromPattern(route) {
  if (route.includes('*')) return 'catchall';
  if (route.includes(':')) return 'dynamic';
  return 'static';
}

function stableSortRoutes(routes) {
  // 1) static 2) dynamic 3) catchall
  const rank = { static: 0, dynamic: 1, catchall: 2 };
  return routes.sort((a, b) => {
    const ra = rank[a.type] ?? 3;
    const rb = rank[b.type] ?? 3;
    if (ra !== rb) return ra - rb;
    return a.route.localeCompare(b.route);
  });
}

export async function bundle({
  cwd = process.cwd(),
  srcDir = 'src-api',
  outFile = 'dist/worker.mjs',
  prettyDefault = false,
  watch = false,
}) {
  const root = path.resolve(cwd, srcDir);
  const files = await walkJs(root);

  const entries = [];
  for (const fileAbs of files) {
    if (IGNORED.test(fileAbs.replace(root, ''))) continue;
    const route = fileToRoute(root, fileAbs);
    const type = routeTypeFromPattern(route);
    const { code } = await loadRouteModule(fileAbs);

    entries.push({
      file: path.relative(cwd, fileAbs).replace(/\\/g, '/'),
      route,
      type,
      dataSrc: code.data,
      pathsSrc: code.paths || null,
    });
  }

  const list = stableSortRoutes(entries);

  const registrySource = `
export const REGISTRY = [
${list
  .map(
    (e) => `  {
    route: ${JSON.stringify(e.route)},
    type: ${JSON.stringify(e.type)},
    file: ${JSON.stringify(e.file)},
    mod: (function(){
      ${e.pathsSrc ? `const paths = ${e.pathsSrc};` : ''}
      const data = ${e.dataSrc};
      return { ${e.pathsSrc ? 'paths,' : ''} data };
    })()
  }`
  )
  .join(',\n')}
];
export const DEFAULT_PRETTY = ${prettyDefault ? 'true' : 'false'};
`;

  // Write a temporary module for registry + runtime glue and let esbuild concat/minify
  const tmpDir = path.join(cwd, '.statikapi-cf-tmp');
  await fs.mkdir(tmpDir, { recursive: true });
  const entryFile = path.join(tmpDir, 'entry.mjs');
  const runtimeFile = path.join(tmpDir, 'runtime.mjs');

  // write entry + runtime
  await fs.writeFile(entryFile, registrySource, 'utf8');
  await fs.writeFile(runtimeFile, WORKER_RUNTIME_JS, 'utf8');

  const buildOpts = {
    entryPoints: [runtimeFile],
    bundle: true,
    format: 'esm',
    platform: 'browser',
    outfile: path.resolve(cwd, outFile),
    define: { 'process.env.NODE_ENV': '"production"' },
    banner: { js: '// generated by @statikapi/adapter-cf\n' },
    logLevel: 'silent',
  };

  if (watch) {
    const ctx = await esbuild.context(buildOpts);
    await ctx.watch();
    // don’t rm tmpDir in watch mode
    return;
  }

  await esbuild.build(buildOpts);

  try {
    await fs.rm(tmpDir, { recursive: true, force: true });
  } catch {
    // ignore catch
  }
}

// -------------------------
// Worker runtime (pure JS) inlined here
// -------------------------
const WORKER_RUNTIME_JS = `
  import { REGISTRY, DEFAULT_PRETTY } from './entry.mjs';

  // -------------------------
  // Helpers
  // -------------------------
  function isPlainObject(x){ return Object.prototype.toString.call(x) === '[object Object]'; }
  function assertSerializable(v, seen = new Set()) {
    const t = typeof v;
    if (v == null) return;
    if (t === 'string' || t === 'boolean') return;
    if (t === 'number') { if (!Number.isFinite(v)) throw new Error('Not JSON-serializable: Number must be finite'); return; }
    if (Array.isArray(v)) { for (const it of v) assertSerializable(it, seen); return; }
    if (t === 'object') {
      if (seen.has(v)) throw new Error('Not JSON-serializable: Circular structure detected');
      if (!isPlainObject(v)) throw new Error('Not JSON-serializable: Only plain objects/arrays allowed');
      seen.add(v);
      for (const k of Object.keys(v)) assertSerializable(v[k], seen);
      seen.delete(v);
      return;
    }
    throw new Error('Not JSON-serializable: ' + t + ' is not allowed');
  }

  function splitRoute(route) {
    if (route === '/') return [];
    return route.replace(/^\\//,'').split('/');
  }

  // -------------------------
  // Config helpers
  // -------------------------
  function useIndexJson(env) {
    return (env.STATIK_USE_INDEX_JSON || 'true').toLowerCase() === 'true';
  }

  // -------------------------
  // Routing helpers
  // -------------------------
  function matchPattern(patternRoute, concreteRoute) {
    const pSegs = splitRoute(patternRoute);
    const cSegs = splitRoute(concreteRoute);

    const params = {};
    let i = 0, j = 0;

    while (i < pSegs.length && j < cSegs.length) {
      const p = pSegs[i];
      const c = cSegs[j];

      if (p.startsWith(':')) {
        params[p.slice(1)] = decodeURIComponent(c);
        i++; j++;
      } else if (p.startsWith('*')) {
        const name = p.slice(1);
        const rest = cSegs.slice(j).map((s) => decodeURIComponent(s));
        params[name] = rest;
        i = pSegs.length;
        j = cSegs.length;
        break;
      } else {
        if (p !== c) return null;   // no match
        i++; j++;
      }
    }

    if (i !== pSegs.length || j !== cSegs.length) return null;
    return params; // matched!
  }

  function findRouteEntry(registry, concreteRoute) {
    for (const r of registry) {
      const params = matchPattern(r.route, concreteRoute);
      if (params) {
        return { routeEntry: r, params };
      }
    }
    return null;
  }

  function concreteFromPattern(patternSegs, entry) {
    // entry can be string (for single dynamic) or array for catchall
    const params = {};
    const segs = [];
    let idxDyn = 0;
    for (const s of patternSegs) {
      if (s.startsWith(':')) {
        const val = Array.isArray(entry) ? entry[idxDyn++] : entry;
        params[s.slice(1)] = String(val);
        segs.push(String(val));
      } else if (s.startsWith('*')) {
        const name = s.slice(1);
        const arr = Array.isArray(entry) ? entry.slice(idxDyn) : (Array.isArray(entry) ? entry : [entry]);
        params[name] = arr.map(String);
        segs.push(...params[name]);
        break;
      } else {
        segs.push(s);
      }
    }
    const route = '/' + segs.join('/');
    return { route, params };
  }

  async function expandAllRoutes(registry) {
    const out = [];
    for (const r of registry) {
      const patternSegs = splitRoute(r.route);
      if (r.type === 'static') {
        out.push({ ...r, concreteRoute: r.route, params: {} });
        continue;
      }
      if (r.mod && typeof r.mod.paths === 'function') {
        const entries = await r.mod.paths();
        if (!Array.isArray(entries)) throw new Error('paths() must return an array');
        for (const entry of entries) {
          if (r.type === 'dynamic' && (typeof entry !== 'string' || !entry || entry.includes('/'))) {
            throw new Error('paths() for ' + r.route + ' must be string[] without "/"');
          }
          if (r.type === 'catchall') {
            if (!Array.isArray(entry) || !entry.length) throw new Error('paths() for ' + r.route + ' must be non-empty string[] arrays');
            if (entry.some(s => typeof s !== 'string' || !s)) throw new Error('catch-all entries must be non-empty strings');
          }
          const { route, params } = concreteFromPattern(patternSegs, entry);
          out.push({ ...r, concreteRoute: route, params });
        }
      }
    }
    return out;
  }

  async function digestETag(text) {
    const enc = new TextEncoder().encode(text);
    const hash = await crypto.subtle.digest('SHA-256', enc);
    const hex = [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, '0')).join('');
    return '"' + hex + '"';
  }

  // -------------------------
  // R2 key mapping
  // -------------------------

  // From concrete route ('/', '/posts', '/users/1') to canonical R2 key.
  function r2KeyForRoute(concreteRoute, env) {
    const useIndex = useIndexJson(env);

    if (concreteRoute === '/') {
      // root
      return useIndex ? 'index.json' : 'index';
    }

    const clean = concreteRoute.replace(/^\\/+/, '');

    if (useIndex) {
      // index.json mode: posts -> posts/index.json
      return clean + '/index.json';
    }

    // flat mode: posts -> posts
    return clean;
  }

  // All public paths that *should* map to a given route
  // (used only for worker cache purge; actual public access is via R2 now).
  function publicPathsForRoute(route, env) {
    const useIndex = useIndexJson(env);

    if (route === '/') {
      if (useIndex) {
        // root index.json plus '/'
        return ['/', '/index.json'];
      }
      // flat root: underlying key 'index', but we still may serve '/', '/index', '/index.json'
      return ['/', '/index', '/index.json'];
    }

    const base = route; // e.g. '/posts', '/users/1'

    if (useIndex) {
      // index.json mode: primary JSON path is '/posts/index.json'
      return [base + '/index.json'];
    }

    // flat keys: underlying key is 'posts' or 'users/1'
    // purge both extensionless and .json alias
    return [base, base + '.json'];
  }

  async function writeJsonToR2(env, key, text, extraMeta = {}) {
    const httpMetadata = {
      contentType: 'application/json; charset=utf-8',
      cacheControl: 'public, max-age=0, s-maxage=31536000',
    };
    await env.STATIK_BUCKET.put(key, text, { httpMetadata, customMetadata: extraMeta });
  }

  const MANIFEST_KEY = 'manifest';

  function getManifestNS(env) {
    const bindingName = env.STATIK_MANIFEST_BINDING || 'STATIK_MANIFEST';
    const ns = env[bindingName];
    if (!ns) {
      throw new Error(\`KV namespace binding "\${bindingName}" not found on env\`);
    }
    return ns;
  }

  async function readManifest(env) {
    const ns = getManifestNS(env);
    const m = await ns.get(MANIFEST_KEY);
    if (!m) return [];
    try { return JSON.parse(m); } catch { return []; }
  }

  async function writeManifest(env, list) {
    const ns = getManifestNS(env);
    await ns.put(MANIFEST_KEY, JSON.stringify(list));
  }

  // -------------------------
  // Cache purge helpers
  // -------------------------
  async function purgeCacheForPath(origin, path) {
    try {
      const url = origin + path;
      await caches.default.delete(new Request(url, { method: 'GET' }));
    } catch (err) {
      // best-effort
      console.warn('purgeCacheForPath error', err);
    }
  }

  // -------------------------
  // Build single route
  // -------------------------
  async function handleBuildRoute(req, env) {
    const auth = req.headers.get('authorization') || '';
    const want = 'Bearer ' + (env.STATIK_BUILD_TOKEN || '');
    if (!env.STATIK_BUILD_TOKEN || auth !== want) {
      return new Response('unauthorized', { status: 401 });
    }

    const url = new URL(req.url);
    const body = await req.json().catch(() => ({}));
    const pretty = body.pretty ?? DEFAULT_PRETTY;

    // prefer query ?route=... but fall back to body.route for backwards-ish compat
    const route = url.searchParams.get('route') || body.route;

    if (!route || typeof route !== 'string') {
      return new Response(JSON.stringify({ ok: false, error: 'Missing "route" (use ?route=/path) in request' }), {
        status: 400,
        headers: { 'content-type': 'application/json' },
      });
    }

    const found = findRouteEntry(REGISTRY, route);
    if (!found) {
      return new Response(JSON.stringify({ ok: false, error: 'No matching route in registry' }), {
        status: 404,
        headers: { 'content-type': 'application/json' },
      });
    }

    const { routeEntry, params } = found;

    const ctx = { params: params || {}, env };
    const value = await routeEntry.mod.data(ctx);
    assertSerializable(value);

    const text = pretty ? JSON.stringify(value, null, 2) : JSON.stringify(value);
    const key = r2KeyForRoute(route, env);
    const etag = await digestETag(text);

    await writeJsonToR2(env, key, text, { route, etag });

    // update manifest: remove old entry for this route, then add fresh one
    const existing = await readManifest(env);
    const next = (existing || []).filter((e) => e.route !== route);
    const bytes = (new TextEncoder().encode(text)).length;

    next.push({
      route,
      filePath: key,
      bytes,
      mtime: Date.now(),
      hash: etag.replace(/"/g, ''),
    });

    await writeManifest(env, next);

    // per-route cache purge (worker cache) for all public paths of this route
    const origin = url.origin;
    for (const p of publicPathsForRoute(route, env)) {
      await purgeCacheForPath(origin, p);
    }

    const resBody = {
      ok: true,
      route,
      filePath: key,
      bytes,
    };

    return new Response(JSON.stringify(resBody), {
      headers: { 'content-type': 'application/json' },
    });
  }

  // -------------------------
  // Build all routes
  // -------------------------
  async function handleBuild(req, env) {
    const auth = req.headers.get('authorization') || '';
    const want = 'Bearer ' + (env.STATIK_BUILD_TOKEN || '');
    if (!env.STATIK_BUILD_TOKEN || auth !== want) {
      return new Response('unauthorized', { status: 401 });
    }
    const body = await req.json().catch(() => ({}));
    const pretty = body.pretty ?? DEFAULT_PRETTY;

    const t0 = Date.now();
    let written = 0, files = 0, skipped = 0;

    const expanded = await expandAllRoutes(REGISTRY);
    const man = [];

    const url = new URL(req.url);
    const origin = url.origin;

    for (const r of expanded) {
      if (!r.concreteRoute) { skipped++; continue; }
      const ctx = { params: r.params || {}, env };
      const value = await r.mod.data(ctx);
      assertSerializable(value);
      const text = pretty ? JSON.stringify(value, null, 2) : JSON.stringify(value);
      const key = r2KeyForRoute(r.concreteRoute, env);
      const etag = await digestETag(text);
      await writeJsonToR2(env, key, text, { route: r.concreteRoute, etag });

      // per-route purge for all public paths of this route
      for (const p of publicPathsForRoute(r.concreteRoute, env)) {
        await purgeCacheForPath(origin, p);
      }

      files++;
      written += (new TextEncoder().encode(text)).length;
      man.push({
        route: r.concreteRoute,
        filePath: key,
        bytes: text.length,
        mtime: Date.now(),
        hash: etag.replace(/"/g, '')
      });
    }

    await writeManifest(env, man);

    const ms = Date.now() - t0;
    return new Response(JSON.stringify({ ok: true, files, bytes: written, skipped, ms }), {
      headers: { 'content-type': 'application/json' }
    });
  }

  // -------------------------
  // Entry
  // -------------------------
  export default {
    async fetch(req, env) {
      const url = new URL(req.url);

      // Minimal OPTIONS handler
      if (req.method === 'OPTIONS') {
        return new Response(null, { status: 204 });
      }

      if (req.method === 'POST' && url.pathname === '/build') {
        // /build?route=/posts/1  -> single route build
        if (url.searchParams.has('route')) {
          return handleBuildRoute(req, env);
        }
        // /build  -> full build
        return handleBuild(req, env);
      }

      if (req.method === 'GET' && url.pathname === '/manifest') {
        const list = await readManifest(env);
        return new Response(JSON.stringify(list), { headers: { 'content-type': 'application/json' } });
      }

      return new Response('Not found', { status: 404 });
    }
  };
`;
